---
layout: post
title: "深入理解java虚拟机 摘要（一）--运行时数据区域"
subtitle: "自动内存管理机制"
date: 
author: "王鹏"
header-img: 
cdn: 'header-off'
tags: 
        - 'java虚拟机' 
        - 'java'
---
# 深入理解java虚拟机 摘要 #
***
## 一、自动内存管理机制 ##
***
### 1. 运行时数据区域 ###
* 程序计数器（线程私有）：

    >一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。
* JAVA虚拟机栈（线程私有）:

    >Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧,用于存储局部变量表、操作数栈、动态链接、方法出口等信息。

    >StackOverflowError异常: 如果线程请求的栈度大于虚拟机所允许的深度

    >OutOfMemoryError异常: 如果虚拟机栈可以动扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存
* 本地方法栈 （线程私有）
    >与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。

    >本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常

* java堆 也叫GC堆 （线程共享）
    >此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存,是垃圾收集器管理的主要区域,处于物理上不连续的内存空间中，只要逻辑上是连续的即可

    >OutOfMemoryError异常: 如果在堆中没有内存完成实例分配，并且堆也无法再扩展

* 方法区（线程共享）
    >与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

    >对于习惯在HotSpot虚拟机上开发、部署程序的开发者来说，很多人都更愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。

* 运行时常量池（线程共享)
    >是方法区的一部分,用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

    >运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern（）方法。

    >OutOfMemoryError异常:当常量池无法再申请到内存时

* 直接内存
    >并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。，它可以使用Native函数库直接分配堆外内存。

   >OutOfMemoryError异常:本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。